http://www.scienjus.com/database-sharding-review/

０．　在开发初期，为了快速实现功能，一般会将所有数据存放在单个数据库上。
    　单个数据库最大的缺点是一旦该数据库由于某些原因挂掉，整个软件的所有功能都面临瘫痪
１．　所以为了保证数据库的高可用，通常会再加一个数据库与其形成主从关系（Master-Slave）。　为了容灾，对性能没有任何提升。
２．　当遇到第一次数据库性能问题时，最先想到的方案应该是读写分离，将所有写操作都放在主数据库上，所有读操作都放在从数据库上，这样至少可以将
    　主数据库的压力减半，并且由于大部分软件都是读多写少，所以可以配置一主多从进一步减少数据库的读压力。
３． 　加入缓存（使用Memcached或Redis），与数据库本身没有太大关系就不细说了，一般来说读写分离加上缓存已经可以应付绝大多数情况　  
４．　如果再次遇到性能问题，则需要根据业务逻辑进行选择更进一步的方案了，一般有以下几种：
        a). 对数据库垂直分库。将业务彼此无关的表放在单独的数据库中，分库后不同库中的表无法进行联合查询等操作，但是可以平摊压力，并且独立做读写分离
        b). 对数据库进行水平分表，建立多个结构相同的表分摊数据，使得每个表的数据量减少从而提升速度。
        
水平分片策略:
1. 基于id的区间分片，例如：将id为1-2w的数据存放在A数据库，2w-4w的数据存放在B数据库。缺点是单库能承受的数据量需要预估，如果预估的不准确容易造成
   性能不够用或者浪费。
2. 基于id的hash分片，例如：将id%2=0的数据存放在A数据库，id%2=1的数据放在B数据库。缺点是在动态增加数据库时，hash的结果会发生变化，所以需要对
   已有数据进行迁移，一般是用一致性hash或在分库初期就建立足够的数据库避免这个问题。
3. 基于时间的区间分片，大部分软件都会有一个特征：越新的数据被操作的几率越大，老数据几乎不会被操作。所以通过数据的插入时间进行分库（也称为冷热分离），
   例如：将2015年1月-5月的数据放在一个库，6月到12月的数据放在另一个库。这样做的缺点是在查询时需要额外提供数据的创建时间才能找到数据存放在哪个库，
   所以比较适合微博等主要以时间轴（Timeline）功能为主的软件。
4. 基于检索表分片，通过额外建立一张检索表保存id与所在数据库节点的对应关系，优点是逻辑简单，自由且不会有迁移问题，缺点是每次查询都需要额外查询检索表，
   所以一般会选择将检索表缓存到内存中。
5. 基于地理位置分片，像点评、滴滴打车之类的软件由于不同城市的数据不需要互通，可以按照城市分片，将不同城市的数据存放在不同数据库中，这样做的一个优点是
   可以将数据库服务器部署到离对应城市最近的节点上，以提高访问速度。
